---
layout: post
title: "Spring Study - 6"
date: 2020-12-15
tags: [spring, backend]
category : [study]
comments: true
---

### 6. 스프링 DB 접근 기술

### 목차  
1. <a href="#1">H2 데이터베이스 설치</a>  
2. <a href="#2">순수 JDBC</a>
3. <a href="#3">스프링 통합 테스트</a>
4. <a href="#4">스프링 JdbcTemplate</a>
5. <a href="#5">JPA</a>
6. <a href="#6">스프링 데이터 JPA</a>


수강 코스는 <a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/">인프런 스프링 입문 강의</a>를 듣고 있습니다.  

---

<a name="1"></a>
### H2 데이터베이스 설치
- 데이터 베이스 연결의 역사
  1. JDBC를 이용해 DB와 Spring을 연결
  2. 스프링이 이후 JDBC 템플릿으로 편리하게 연결해주는 방법을 도입
  3. 이후에는 SQL 조차도 직접 짜는게 아니라 조회쿼리 등을 날려주는 `JPA`라는 기술로 객체를 바로 DB에 쿼리없이 저장해주는 기술을 사용한다. 이를 스프링에서 편리하게 쓸 수 있도록 한 번 감싼 기술을 `스프링 데이터 JPA`라고 한다.
- H2는 메뉴얼을 따라 하면 된다.

```sql
drop table if exists member CASCADE;
create table member
(
 id bigint generated by default as identity,
 name varchar(255),
 primary key (id)
);
```

위의 코드를 H2에 입력하여 테이블 관리를 위한 `sql/ddl.sql`을 생성해준다.
id는 자바에서는 long이고 db에서는 bigint를 사용했고, generated by default as identity는 null로 들어오더라도 자동으로 값을 채워준다.

---

<a name="2"></a>
### 순수 JDBC
아주 예전 방식의 데이터저장기술로, 역사를 듣는다는 생각으로 키워드만 정리하면 된다고 하신다.

```sql
private final DataSource dataSource; //DB에 붙기 위한 데이터소스

public JdbcMemberRepository(DataSource dataSource) {
    this.dataSource = dataSource;
}

@Override
public Member save(Member member) {
    String sql = "insert into member(name) values(?)";
    Connection conn = dataSource.getConnection();
    PreparedStatement pstmt = conn.prepareStatement(sql);
    pstmt.setString(1, member.getName());
    //..어쩌구저쩌구..
    pstmt.executeUpdate();
    return null;
}
```

이런 식으로 진행되는데, 각 메소드를 다 지정해주어야하기 때문에 노가다 작업이다.
- 다형성을 이용해 빠르게 확장이 가능하다  
  => **개방-폐쇄 원칙 (OCP, Open-Closed Princople)**  
    : 확장에는 열려있고, 수정, 변경에는 닫혀있다. <= 객체지향의 장점 (구현제 변경 없이 쉽게 확장이 가능하다는 점)
---

<a name="3"></a>
### 스프링 통합 테스트
- 스프링 + DB 를 통합하여 테스트
- `@Transactional`
  - DB는 commit 전에는 쿼리가 적용이 안된다(트랜잭션). 테스트 시작 전에 트랜잭션을 시작하고, 테스트가 끝나면 롤백을 해주는 어노테이션이다.
  - 롤백을 해주므로 테스트 여러개를 반복할 수 있다.
- `@SpringBootTest`
  - 스프링 컨테이너와 테스트를 같이 실행하는 것.  
  <-> **단일 테스트**  
    : 자바 코드? 메소드 하나의 단위로 테스트를 하는 것. 시간도 짧게 걸리고, 보다 정확하게 테스트할 확률이 높으므로 단일테스트로도 모두 테스트가 가능하게끔 테스트를 설계해야 한다.

---

<a name="4"></a>
### 스프링 JdbcTemplate
- 마이바티스와 유사한 느낌
- JDBC API 중복 코드를 제거해준다. 실무에서 많이 쓴다.
- 생성자가 하나면 @autowired를 생략할 수 있다.

---

<a name="5"></a>
### JPA
- JPA는 SQL, 데이터 중심설계에서 객체중심설계로 옮겨준다.
- `spring.jpa.show-sql = true` : jpa가 날리는 sql을 볼 수 있다.
- `spring.jpa.hibernate.ddl-auto=none`
  - hibernate는 자바 객체를 RDMS의 하나의 ROW로 매핑해준다.
  - ddl-auto 설정을 통해 웹 어플리케이션이 올라갈 때 Data Source에 접근해 자동으로 DBMS에 테이블을 생성해줄 수 있다. (해당 강의에서는 none으로 설정하여 사용을 해제해준다.)
- `@Entity`
  - JPA 사용을 위한 어노테이션이다. JPA는 자바 진영 표준 인터페이스이고, 구현체 중 하나가 Hibernate이다.
    - Hibernate는 ORM으로, Object Relational Mapping을 의미한다. (Object를 Relational-DBMS ROW로 매핑해준다.)

```java
@Entity
public class Member {
  @Id @GeneratedValue(...)
  .
  .
  .
  private Long id;
  private String name;
  Getter and Setter . . .
}
```

이런 식으로 데이터 클래스(?)의 위에 @Entity 어노테이션을 붙여주면 이하의 클래스를 hibernate가 관리하게 된다.
   - `@Id` : pk(primary key)로 사용한다
   - `@GeneratedValue(strategy = GenerationType.IDENTITY)`
    : Id처럼 DB가 pk를 자동으로 생성해준다.

- `EntityManager` : JPA에서 사용하는 인스턴스로, 이를 사용해 DB와 통신한다.
  - 어플리케이션과 데이터베이스 사이에 영속성 컨텍스트(Persistence Context)라는 개념을 두고 데이터를 관리하게 된다.
  - 이를 사용하면 EntityManager가 insert 쿼리를 만들어서 넣어주고, get name 등 까지 자동으로 다 해준다.
  - 항상 `@Transactional`이 붙어있어야 작동한다.

```java
package hello.hellospring.repository;

import hello.hellospring.domain.Member;

import javax.persistence.EntityManager;
import javax.persistence.TypedQuery;
import javax.transaction.Transactional;
import java.util.List;
import java.util.Optional;

public class JpaMemberRepository implements MemberRepository {

    private final EntityManager em;

    public JpaMemberRepository(EntityManager em) {
        this.em = em;
    }

    @Override
    public Member save(Member member) {
        em.persist(member);
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
        Member member = em.find(Member.class, id);
        return Optional.ofNullable(member);
    }

    @Override
    public Optional<Member> findByName(String name) {
        List<Member> result = em.createQuery("select m from Member m where m.name = :name", Member.class)
                .setParameter("name", name)
                .getResultList();
        return result.stream().findAny();
    }

    @Override
    public List<Member> findAll() {
        return em.createQuery("select m from Member m", Member.class)
                .getResultList();
    }
}
```

보면 일반 sql 쿼리와는 다르게 진행된다.      
- save의 경우에도 persist 메소드를 사용해 EntityManager에 member를 넣는 방식으로 동작한다. (return member 해준건, 사실 안해줘도 되지만 이전에 Test를 저 방식으로 짰기 때문에 추가)
- findById를 보면 sql 쿼리를 날리지 않고, EntityManager의 find 메소드를 사용해 찾아준다.
- findByName과 findAll을 보면 SQL 쿼리와 다르게 Member m 객체를 그대로 받아와서, result로 넘겨주고, 이를 List로 만들어 return해주는 것을 볼 수 있다. (findByName은 `stream().findAny()` 메소드를 사용하여 해당 스트림에서 첫 번째 요소를 참조하는 Optional 객체를 반환해주고 있다.)

---

<a name="6"></a>
### 스프링 데이터 JPA
- 인터페이스만으로도 개발이 가능해지며, 단순반복이라 생각되는 개발적 요소를 없앨 수 있어 개발생산성 증대 가능
- 인터페이스만 있으면 Bean에 자동으로 등록해준다.
- findById가 JPA에서 기본적으로 제공이 된다. pk 검색도 가능하고, 왠만한 공통 인터페이스가 다 제공된다.


---
